# ESC-based Engine Demo

Основа графического движка: умеет крутить крысу

1. Модель ECS
1. Загрузка .obj моделей
1. Сериализация
1. Поддержка Lua-скриптов

## Архитектура

1. ECS: Компоненты хранятся в `std::unordered_map<Entity, ComponentType>`. Entity - просто uint32_t, генерируемый последовательно. Можно итерироваться по мапе для обработки сущностей одного типа.
1. ResourceManager: загрузка .obj реализована однократно - ресурсы хранятся в `std::unordered_map<std::string, std::shared_ptr<Model>>`. Используется std::shared_ptr, т.к. могут быть несколько компонентов или систем, держащих ссылки на один и тот же ресурс. Альтернативный вариант: unique_ptr + weak_ptr, но shared_ptr оставлен для простоты.
1. Сериализация: формат JSON (через nlohmann/json.hpp). Предоставляет человекочитаемый текст, поддерживает сложные структуры и легко расширяется. Альтернативный вариант: бинарный формат (например, protobuf) для производительности, но для демо JSON удобнее.
1. Lua: чистый Lua C API, без сторонних обёрток. ScriptingSystem создаёт один lua_State*, регистрирует функции для управления TransformComponent (get/set позицию, rotate) через глобальные функции Lua. Перед вызовом каждого скрипта выставляется глобальная переменная entity_id и dt. Lua-скрипт должен определять функцию update(), которая вызывается каждый фрейм: внутри вызывает get_position(), set_position(...), rotate(...).

## Сборка

Для сборки требуется установленный девкит Lua и OpenGL.

`sudo apt install liblua5.3-dev`

Зависисоти GLFW:

`sudo apt install libwayland-dev libxkbcommon-dev xorg-dev`

Конфигурация:
`cmake -B build`

В процессе скачиваются необходимые библтотеки, может быть  долго.

Сборка: `cmake --build build`

Запуск: `./build/ecs_demo`

Форматтер: `cmake --build build -t clang-format`
